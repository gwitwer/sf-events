<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SF Bay Area Events Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; }
        
        #map { height: 100vh; width: 100%; }
        
        .controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            max-width: 350px;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .controls h2 { margin-bottom: 15px; font-size: 18px; }
        
        .filter-section {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #eee;
        }
        
        .filter-section:last-child { border-bottom: none; }
        
        .filter-section label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            font-size: 14px;
        }
        
        select, input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .genre-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 5px;
        }
        
        .genre-tag {
            padding: 4px 8px;
            background: #f0f0f0;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            border: 1px solid transparent;
            transition: all 0.2s;
        }
        
        .genre-tag:hover { background: #e0e0e0; }
        .genre-tag.selected {
            background: #4CAF50;
            color: white;
            border-color: #45a049;
        }
        
        .stats {
            padding: 10px;
            background: #f9f9f9;
            border-radius: 4px;
            font-size: 13px;
            color: #666;
        }
        
        .event-popup {
            max-width: 300px;
        }
        
        .event-popup h3 {
            margin-bottom: 10px;
            font-size: 16px;
            color: #333;
        }
        
        .event-details {
            font-size: 14px;
            line-height: 1.5;
        }
        
        .event-details div {
            margin-bottom: 5px;
        }
        
        .event-link {
            display: inline-block;
            margin-top: 10px;
            padding: 6px 12px;
            background: #4CAF50;
            color: white;
            text-decoration: none;
            border-radius: 4px;
            font-size: 13px;
        }
        
        .event-link:hover { background: #45a049; }
        
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 2000;
        }
        
        .clear-cache {
            margin-top: 10px;
            padding: 6px 12px;
            background: #ff5252;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .clear-cache:hover { background: #ff3333; }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <div class="controls">
        <h2>SF Bay Area Events 🎵</h2>
        
        <div class="filter-section">
            <label for="daySelector">Day</label>
            <select id="daySelector">
                <option value="all">All Events</option>
                <option value="friday">Friday Events</option>
                <option value="saturday">Saturday Events</option>
            </select>
        </div>
        
        <div class="filter-section">
            <label for="dateFilter">Date Range</label>
            <input type="date" id="startDate" />
            <input type="date" id="endDate" style="margin-top: 5px;" />
        </div>
        
        <div class="filter-section">
            <label for="cityFilter">City</label>
            <select id="cityFilter">
                <option value="">All Cities</option>
            </select>
        </div>
        
        <div class="filter-section">
            <label>Genres (click to filter)</label>
            <div class="genre-tags" id="genreTags"></div>
        </div>
        
        <div class="stats" id="stats">
            Loading events...
        </div>
        
        <button class="clear-cache" onclick="clearGeocodeCache()">Clear Location Cache</button>
    </div>
    
    <div class="loading" id="loading">
        <div>Loading events and geocoding venues...</div>
        <div id="geocodeProgress" style="margin-top: 10px; font-size: 12px; color: #666;"></div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
    <script>
        let map;
        let markers;
        let allEvents = [];
        let geocodeCache = {};
        let selectedGenres = new Set();
        
        // Initialize map centered on SF Bay Area
        function initMap() {
            map = L.map('map').setView([37.7749, -122.4194], 10);
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors'
            }).addTo(map);
            
            markers = L.markerClusterGroup({
                chunkedLoading: true,
                spiderfyOnMaxZoom: true,
                showCoverageOnHover: false,
                maxClusterRadius: 50
            });
            
            map.addLayer(markers);
        }
        
        // Load geocode cache from localStorage
        function loadGeocodeCache() {
            const cached = localStorage.getItem('geocodeCache');
            if (cached) {
                try {
                    geocodeCache = JSON.parse(cached);
                    console.log(`Loaded ${Object.keys(geocodeCache).length} cached locations`);
                } catch (e) {
                    console.error('Failed to load cache:', e);
                }
            }
        }
        
        // Save geocode cache to localStorage
        function saveGeocodeCache() {
            try {
                localStorage.setItem('geocodeCache', JSON.stringify(geocodeCache));
            } catch (e) {
                console.error('Failed to save cache:', e);
            }
        }
        
        // Clear geocode cache
        function clearGeocodeCache() {
            geocodeCache = {};
            localStorage.removeItem('geocodeCache');
            alert('Location cache cleared. Reload the page to re-geocode venues.');
        }
        
        // Geocode a venue using Nominatim
        async function geocodeVenue(venue, city) {
            const cacheKey = `${venue}|${city}`;
            
            // Check cache first
            if (geocodeCache[cacheKey]) {
                return geocodeCache[cacheKey];
            }
            
            // Rate limiting - wait 1 second between requests
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            const query = `${venue}, ${city}, CA`;
            const url = `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(query)}&format=jsonv2&limit=1`;
            
            try {
                const response = await fetch(url);
                const data = await response.json();
                
                if (data && data.length > 0) {
                    const result = {
                        lat: parseFloat(data[0].lat),
                        lon: parseFloat(data[0].lon),
                        display_name: data[0].display_name
                    };
                    geocodeCache[cacheKey] = result;
                    saveGeocodeCache();
                    return result;
                }
            } catch (e) {
                console.error(`Failed to geocode ${venue}, ${city}:`, e);
            }
            
            // Fallback to city center if venue not found
            const cityQuery = `${city}, CA`;
            const cityUrl = `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(cityQuery)}&format=jsonv2&limit=1`;
            
            try {
                const response = await fetch(cityUrl);
                const data = await response.json();
                
                if (data && data.length > 0) {
                    const result = {
                        lat: parseFloat(data[0].lat),
                        lon: parseFloat(data[0].lon),
                        display_name: `${venue} (approximate location)`,
                        approximate: true
                    };
                    geocodeCache[cacheKey] = result;
                    saveGeocodeCache();
                    return result;
                }
            } catch (e) {
                console.error(`Failed to geocode city ${city}:`, e);
            }
            
            return null;
        }
        
        // Load events from the JSON file
        async function loadEvents(dayFilter = 'all') {
            try {
                let filename;
                let useGeocoded = false;
                
                // Always try the fully geocoded file first
                try {
                    const testResponse = await fetch('events_all_geocoded.json');
                    if (testResponse.ok) {
                        filename = 'events_all_geocoded.json';
                        useGeocoded = true;
                    }
                } catch (e) {
                    // Fall back to day-specific or main file
                }
                
                // If no complete geocoded file, check for day-specific files
                if (!useGeocoded) {
                    if (dayFilter === 'friday') {
                        // Try geocoded file first
                        try {
                            const testResponse = await fetch('events_friday_geocoded.json');
                            if (testResponse.ok) {
                                filename = 'events_friday_geocoded.json';
                                useGeocoded = true;
                            }
                        } catch (e) {
                            // Fall back to main file
                            filename = 'events-2025-08-29T19-48-28.json';
                        }
                    } else if (dayFilter === 'saturday') {
                        // Try geocoded file first
                        try {
                            const testResponse = await fetch('events_saturday_geocoded.json');
                            if (testResponse.ok) {
                                filename = 'events_saturday_geocoded.json';
                                useGeocoded = true;
                            }
                        } catch (e) {
                            // Fall back to main file
                            filename = 'events-2025-08-29T19-48-28.json';
                        }
                    } else {
                        filename = 'events-2025-08-29T19-48-28.json';
                    }
                }
                
                const response = await fetch(filename);
                allEvents = await response.json();
                
                // Filter out hidden events
                allEvents = allEvents.filter(event => !event.hidden);
                
                // If using main file, filter by day
                if (!useGeocoded && dayFilter !== 'all') {
                    const dayOfWeek = dayFilter === 'friday' ? 5 : 6; // Friday=5, Saturday=6
                    allEvents = allEvents.filter(event => {
                        const date = new Date(event.dateISO);
                        return date.getDay() === dayOfWeek;
                    });
                }
                
                console.log(`Loaded ${allEvents.length} ${dayFilter} events from ${filename}`);
                
                // If geocoded file, use existing coordinates
                if (useGeocoded) {
                    allEvents.forEach(event => {
                        if (event.coordinates) {
                            event.lat = event.coordinates.lat;
                            event.lon = event.coordinates.lon;
                            event.locationName = event.coordinates.display_name;
                            event.approximate = event.coordinates.approximate;
                        }
                    });
                    
                    // Skip geocoding, display directly
                    document.getElementById('loading').style.display = 'none';
                    populateFilters();
                    displayEvents(allEvents);
                    
                    // Set up filter listeners
                    document.getElementById('cityFilter').addEventListener('change', filterEvents);
                    document.getElementById('startDate').addEventListener('change', filterEvents);
                    document.getElementById('endDate').addEventListener('change', filterEvents);
                } else {
                    // Populate filters and geocode
                    populateFilters();
                    await geocodeAndDisplayEvents();
                }
                
            } catch (error) {
                console.error('Failed to load events:', error);
                document.getElementById('loading').innerHTML = 
                    '<div style="color: red;">Failed to load events. Make sure the event files are in the same directory.</div>';
            }
        }
        
        // Populate filter dropdowns
        function populateFilters() {
            // Get unique cities
            const cities = [...new Set(allEvents.map(e => e.city))].sort();
            const citySelect = document.getElementById('cityFilter');
            cities.forEach(city => {
                const option = document.createElement('option');
                option.value = city;
                option.textContent = city;
                citySelect.appendChild(option);
            });
            
            // Get unique genres
            const genresSet = new Set();
            allEvents.forEach(event => {
                if (event.genres && Array.isArray(event.genres)) {
                    event.genres.forEach(genre => genresSet.add(genre));
                }
            });
            
            const genres = [...genresSet].sort();
            const genreTags = document.getElementById('genreTags');
            genres.forEach(genre => {
                const tag = document.createElement('div');
                tag.className = 'genre-tag';
                tag.textContent = genre;
                tag.onclick = () => toggleGenre(genre, tag);
                genreTags.appendChild(tag);
            });
            
            // Set date range
            const dates = allEvents.map(e => e.dateISO).sort();
            document.getElementById('startDate').value = dates[0];
            document.getElementById('endDate').value = dates[dates.length - 1];
        }
        
        // Toggle genre filter
        function toggleGenre(genre, element) {
            if (selectedGenres.has(genre)) {
                selectedGenres.delete(genre);
                element.classList.remove('selected');
            } else {
                selectedGenres.add(genre);
                element.classList.add('selected');
            }
            filterEvents();
        }
        
        // Geocode venues and display events
        async function geocodeAndDisplayEvents() {
            const uniqueVenues = {};
            allEvents.forEach(event => {
                const key = `${event.venue}|${event.city}`;
                if (!uniqueVenues[key]) {
                    uniqueVenues[key] = { venue: event.venue, city: event.city, events: [] };
                }
                uniqueVenues[key].events.push(event);
            });
            
            const venueKeys = Object.keys(uniqueVenues);
            let geocoded = 0;
            
            document.getElementById('geocodeProgress').textContent = 
                `Geocoding venues: 0 / ${venueKeys.length}`;
            
            for (const key of venueKeys) {
                const { venue, city, events } = uniqueVenues[key];
                const location = await geocodeVenue(venue, city);
                
                if (location) {
                    events.forEach(event => {
                        event.lat = location.lat;
                        event.lon = location.lon;
                        event.locationName = location.display_name;
                        event.approximate = location.approximate;
                    });
                }
                
                geocoded++;
                document.getElementById('geocodeProgress').textContent = 
                    `Geocoding venues: ${geocoded} / ${venueKeys.length}`;
            }
            
            // Hide loading screen
            document.getElementById('loading').style.display = 'none';
            
            // Display all events
            displayEvents(allEvents);
            
            // Set up filter listeners
            document.getElementById('cityFilter').addEventListener('change', filterEvents);
            document.getElementById('startDate').addEventListener('change', filterEvents);
            document.getElementById('endDate').addEventListener('change', filterEvents);
        }
        
        // Display events on map
        function displayEvents(events) {
            markers.clearLayers();
            
            let displayed = 0;
            events.forEach(event => {
                if (event.lat && event.lon) {
                    const marker = L.marker([event.lat, event.lon]);
                    
                    const popupContent = `
                        <div class="event-popup">
                            <h3>${event.title}</h3>
                            <div class="event-details">
                                <div>📅 ${event.dayLabel} ${event.timeRange || ''}</div>
                                <div>📍 ${event.venue}</div>
                                <div>🏙️ ${event.city}</div>
                                ${event.price ? `<div>💵 ${event.price}</div>` : ''}
                                ${event.age ? `<div>🎫 ${event.age}</div>` : ''}
                                ${event.genres && event.genres.length > 0 ? 
                                    `<div>🎵 ${event.genres.slice(0, 3).join(', ')}</div>` : ''}
                                ${event.approximate ? '<div style="color: orange;">⚠️ Approximate location</div>' : ''}
                            </div>
                            ${event.url ? `<a href="${event.url}" target="_blank" class="event-link">More Info</a>` : ''}
                        </div>
                    `;
                    
                    marker.bindPopup(popupContent);
                    markers.addLayer(marker);
                    displayed++;
                }
            });
            
            // Update stats
            document.getElementById('stats').innerHTML = `
                Showing ${displayed} of ${events.length} events<br>
                (${events.length - displayed} venues couldn't be geocoded)
            `;
            
            // Fit map to markers if any exist
            if (displayed > 0) {
                setTimeout(() => {
                    map.fitBounds(markers.getBounds(), { padding: [50, 50] });
                }, 100);
            }
        }
        
        // Filter events based on current selections
        function filterEvents() {
            const cityFilter = document.getElementById('cityFilter').value;
            const startDate = document.getElementById('startDate').value;
            const endDate = document.getElementById('endDate').value;
            
            const filtered = allEvents.filter(event => {
                // City filter
                if (cityFilter && event.city !== cityFilter) return false;
                
                // Date filter
                if (startDate && event.dateISO < startDate) return false;
                if (endDate && event.dateISO > endDate) return false;
                
                // Genre filter
                if (selectedGenres.size > 0) {
                    if (!event.genres || !event.genres.some(g => selectedGenres.has(g))) {
                        return false;
                    }
                }
                
                return true;
            });
            
            displayEvents(filtered);
        }
        
        // Handle day selector change
        function handleDayChange() {
            const dayFilter = document.getElementById('daySelector').value;
            
            // Clear existing markers
            markers.clearLayers();
            
            // Reset filters
            selectedGenres.clear();
            document.querySelectorAll('.genre-tag').forEach(tag => {
                tag.classList.remove('selected');
            });
            
            // Show loading
            document.getElementById('loading').style.display = 'block';
            document.getElementById('loading').innerHTML = 
                '<div>Loading events...</div>';
            
            // Load new events
            loadEvents(dayFilter);
        }
        
        // Initialize everything
        window.addEventListener('load', () => {
            initMap();
            loadGeocodeCache();
            loadEvents('all');
            
            // Set up day selector
            document.getElementById('daySelector').addEventListener('change', handleDayChange);
        });
    </script>
</body>
</html>